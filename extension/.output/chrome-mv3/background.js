var background=function(){"use strict";var q,Q,z,Y;function X(t){return t==null||typeof t=="function"?{main:t}:t}var D=class{constructor(t){if(t==="<all_urls>")this.isAllUrls=!0,this.protocolMatches=[...D.PROTOCOLS],this.hostnameMatch="*",this.pathnameMatch="*";else{const e=/(.*):\/\/(.*?)(\/.*)/.exec(t);if(e==null)throw new j(t,"Incorrect format");const[r,a,d,l]=e;Z(t,a),ee(t,d),this.protocolMatches=a==="*"?["http","https"]:[a],this.hostnameMatch=d,this.pathnameMatch=l}}includes(t){if(this.isAllUrls)return!0;const e=typeof t=="string"?new URL(t):t instanceof Location?new URL(t.href):t;return!!this.protocolMatches.find(r=>{if(r==="http")return this.isHttpMatch(e);if(r==="https")return this.isHttpsMatch(e);if(r==="file")return this.isFileMatch(e);if(r==="ftp")return this.isFtpMatch(e);if(r==="urn")return this.isUrnMatch(e)})}isHttpMatch(t){return t.protocol==="http:"&&this.isHostPathMatch(t)}isHttpsMatch(t){return t.protocol==="https:"&&this.isHostPathMatch(t)}isHostPathMatch(t){if(!this.hostnameMatch||!this.pathnameMatch)return!1;const e=[this.convertPatternToRegex(this.hostnameMatch),this.convertPatternToRegex(this.hostnameMatch.replace(/^\*\./,""))],r=this.convertPatternToRegex(this.pathnameMatch);return!!e.find(a=>a.test(t.hostname))&&r.test(t.pathname)}isFileMatch(t){throw Error("Not implemented: file:// pattern matching. Open a PR to add support")}isFtpMatch(t){throw Error("Not implemented: ftp:// pattern matching. Open a PR to add support")}isUrnMatch(t){throw Error("Not implemented: urn:// pattern matching. Open a PR to add support")}convertPatternToRegex(t){const r=this.escapeForRegex(t).replace(/\\\*/g,".*");return RegExp(`^${r}$`)}escapeForRegex(t){return t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}},K=D;K.PROTOCOLS=["http","https","file","ftp","urn"];var j=class extends Error{constructor(t,e){super(`Invalid match pattern "${t}": ${e}`)}};function Z(t,e){if(!K.PROTOCOLS.includes(e)&&e!=="*")throw new j(t,`${e} not a valid protocol (${K.PROTOCOLS.join(", ")})`)}function ee(t,e){if(e.includes(":"))throw new j(t,"Hostname cannot include a port");if(e.includes("*")&&e.length>1&&!e.startsWith("*."))throw new j(t,"If using a wildcard (*), it must go at the start of the hostname")}const I=((Q=(q=globalThis.browser)==null?void 0:q.runtime)==null?void 0:Q.id)==null?globalThis.chrome:globalThis.browser;var H=Object.prototype.hasOwnProperty;function U(t,e){var r,a;if(t===e)return!0;if(t&&e&&(r=t.constructor)===e.constructor){if(r===Date)return t.getTime()===e.getTime();if(r===RegExp)return t.toString()===e.toString();if(r===Array){if((a=t.length)===e.length)for(;a--&&U(t[a],e[a]););return a===-1}if(!r||typeof t=="object"){a=0;for(r in t)if(H.call(t,r)&&++a&&!H.call(e,r)||!(r in e)||!U(t[r],e[r]))return!1;return Object.keys(e).length===a}}return t!==t&&e!==e}const te=new Error("request for lock canceled");var re=function(t,e,r,a){function d(l){return l instanceof r?l:new r(function(h){h(l)})}return new(r||(r=Promise))(function(l,h){function f(m){try{y(a.next(m))}catch(v){h(v)}}function _(m){try{y(a.throw(m))}catch(v){h(v)}}function y(m){m.done?l(m.value):d(m.value).then(f,_)}y((a=a.apply(t,e||[])).next())})};class ne{constructor(e,r=te){this._value=e,this._cancelError=r,this._queue=[],this._weightedWaiters=[]}acquire(e=1,r=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((a,d)=>{const l={resolve:a,reject:d,weight:e,priority:r},h=B(this._queue,f=>r<=f.priority);h===-1&&e<=this._value?this._dispatchItem(l):this._queue.splice(h+1,0,l)})}runExclusive(e){return re(this,arguments,void 0,function*(r,a=1,d=0){const[l,h]=yield this.acquire(a,d);try{return yield r(l)}finally{h()}})}waitForUnlock(e=1,r=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,r)?Promise.resolve():new Promise(a=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),ae(this._weightedWaiters[e-1],{resolve:a,priority:r})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const r=this._value;this._value-=e.weight,e.resolve([r,this._newReleaser(e.weight)])}_newReleaser(e){let r=!1;return()=>{r||(r=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const r=this._weightedWaiters[e-1];r&&(r.forEach(a=>a.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let r=this._value;r>0;r--){const a=this._weightedWaiters[r-1];if(!a)continue;const d=a.findIndex(l=>l.priority<=e);(d===-1?a:a.splice(0,d)).forEach(l=>l.resolve())}}}_couldLockImmediately(e,r){return(this._queue.length===0||this._queue[0].priority<r)&&e<=this._value}}function ae(t,e){const r=B(t,a=>e.priority<=a.priority);t.splice(r+1,0,e)}function B(t,e){for(let r=t.length-1;r>=0;r--)if(e(t[r]))return r;return-1}var se=function(t,e,r,a){function d(l){return l instanceof r?l:new r(function(h){h(l)})}return new(r||(r=Promise))(function(l,h){function f(m){try{y(a.next(m))}catch(v){h(v)}}function _(m){try{y(a.throw(m))}catch(v){h(v)}}function y(m){m.done?l(m.value):d(m.value).then(f,_)}y((a=a.apply(t,e||[])).next())})};class ie{constructor(e){this._semaphore=new ne(1,e)}acquire(){return se(this,arguments,void 0,function*(e=0){const[,r]=yield this._semaphore.acquire(1,e);return r})}runExclusive(e,r=0){return this._semaphore.runExclusive(()=>e(),1,r)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}const P=((Y=(z=globalThis.browser)==null?void 0:z.runtime)==null?void 0:Y.id)==null?globalThis.chrome:globalThis.browser,T=oe();function oe(){const t={local:V("local"),session:V("session"),sync:V("sync"),managed:V("managed")},e=o=>{const s=t[o];if(s==null){const n=Object.keys(t).join(", ");throw Error(`Invalid area "${o}". Options: ${n}`)}return s},r=o=>{const s=o.indexOf(":"),n=o.substring(0,s),i=o.substring(s+1);if(i==null)throw Error(`Storage key should be in the form of "area:key", but received "${o}"`);return{driverArea:n,driverKey:i,driver:e(n)}},a=o=>o+"$",d=(o,s)=>{const n={...o};return Object.entries(s).forEach(([i,c])=>{c==null?delete n[i]:n[i]=c}),n},l=(o,s)=>o??s??null,h=o=>typeof o=="object"&&!Array.isArray(o)?o:{},f=async(o,s,n)=>{const i=await o.getItem(s);return l(i,(n==null?void 0:n.fallback)??(n==null?void 0:n.defaultValue))},_=async(o,s)=>{const n=a(s),i=await o.getItem(n);return h(i)},y=async(o,s,n)=>{await o.setItem(s,n??null)},m=async(o,s,n)=>{const i=a(s),c=h(await o.getItem(i));await o.setItem(i,d(c,n))},v=async(o,s,n)=>{if(await o.removeItem(s),n!=null&&n.removeMeta){const i=a(s);await o.removeItem(i)}},E=async(o,s,n)=>{const i=a(s);if(n==null)await o.removeItem(i);else{const c=h(await o.getItem(i));[n].flat().forEach(u=>delete c[u]),await o.setItem(i,c)}},x=(o,s,n)=>o.watch(s,n);return{getItem:async(o,s)=>{const{driver:n,driverKey:i}=r(o);return await f(n,i,s)},getItems:async o=>{const s=new Map,n=new Map,i=[];o.forEach(u=>{let g,w;typeof u=="string"?g=u:"getValue"in u?(g=u.key,w={fallback:u.fallback}):(g=u.key,w=u.options),i.push(g);const{driverArea:O,driverKey:M}=r(g),b=s.get(O)??[];s.set(O,b.concat(M)),n.set(g,w)});const c=new Map;return await Promise.all(Array.from(s.entries()).map(async([u,g])=>{(await t[u].getItems(g)).forEach(O=>{const M=`${u}:${O.key}`,b=n.get(M),p=l(O.value,(b==null?void 0:b.fallback)??(b==null?void 0:b.defaultValue));c.set(M,p)})})),i.map(u=>({key:u,value:c.get(u)}))},getMeta:async o=>{const{driver:s,driverKey:n}=r(o);return await _(s,n)},getMetas:async o=>{const s=o.map(c=>{const u=typeof c=="string"?c:c.key,{driverArea:g,driverKey:w}=r(u);return{key:u,driverArea:g,driverKey:w,driverMetaKey:a(w)}}),n=s.reduce((c,u)=>{var g;return c[g=u.driverArea]??(c[g]=[]),c[u.driverArea].push(u),c},{}),i={};return await Promise.all(Object.entries(n).map(async([c,u])=>{const g=await P.storage[c].get(u.map(w=>w.driverMetaKey));u.forEach(w=>{i[w.key]=g[w.driverMetaKey]??{}})})),s.map(c=>({key:c.key,meta:i[c.key]}))},setItem:async(o,s)=>{const{driver:n,driverKey:i}=r(o);await y(n,i,s)},setItems:async o=>{const s={};o.forEach(n=>{const{driverArea:i,driverKey:c}=r("key"in n?n.key:n.item.key);s[i]??(s[i]=[]),s[i].push({key:c,value:n.value})}),await Promise.all(Object.entries(s).map(async([n,i])=>{await e(n).setItems(i)}))},setMeta:async(o,s)=>{const{driver:n,driverKey:i}=r(o);await m(n,i,s)},setMetas:async o=>{const s={};o.forEach(n=>{const{driverArea:i,driverKey:c}=r("key"in n?n.key:n.item.key);s[i]??(s[i]=[]),s[i].push({key:c,properties:n.meta})}),await Promise.all(Object.entries(s).map(async([n,i])=>{const c=e(n),u=i.map(({key:M})=>a(M));console.log(n,u);const g=await c.getItems(u),w=Object.fromEntries(g.map(({key:M,value:b})=>[M,h(b)])),O=i.map(({key:M,properties:b})=>{const p=a(M);return{key:p,value:d(w[p]??{},b)}});await c.setItems(O)}))},removeItem:async(o,s)=>{const{driver:n,driverKey:i}=r(o);await v(n,i,s)},removeItems:async o=>{const s={};o.forEach(n=>{let i,c;typeof n=="string"?i=n:"getValue"in n?i=n.key:"item"in n?(i=n.item.key,c=n.options):(i=n.key,c=n.options);const{driverArea:u,driverKey:g}=r(i);s[u]??(s[u]=[]),s[u].push(g),c!=null&&c.removeMeta&&s[u].push(a(g))}),await Promise.all(Object.entries(s).map(async([n,i])=>{await e(n).removeItems(i)}))},removeMeta:async(o,s)=>{const{driver:n,driverKey:i}=r(o);await E(n,i,s)},snapshot:async(o,s)=>{var c;const i=await e(o).snapshot();return(c=s==null?void 0:s.excludeKeys)==null||c.forEach(u=>{delete i[u],delete i[a(u)]}),i},restoreSnapshot:async(o,s)=>{await e(o).restoreSnapshot(s)},watch:(o,s)=>{const{driver:n,driverKey:i}=r(o);return x(n,i,s)},unwatch(){Object.values(t).forEach(o=>{o.unwatch()})},defineItem:(o,s)=>{const{driver:n,driverKey:i}=r(o),{version:c=1,migrations:u={}}=s??{};if(c<1)throw Error("Storage item version cannot be less than 1. Initial versions should be set to 1, not 0.");const g=async()=>{var G;const p=a(i),[{value:k},{value:R}]=await n.getItems([i,p]);if(k==null)return;const S=(R==null?void 0:R.v)??1;if(S>c)throw Error(`Version downgrade detected (v${S} -> v${c}) for "${o}"`);console.debug(`[@wxt-dev/storage] Running storage migration for ${o}: v${S} -> v${c}`);const ge=Array.from({length:c-S},(W,C)=>S+C+1);let $=k;for(const W of ge)try{$=await((G=u==null?void 0:u[W])==null?void 0:G.call(u,$))??$}catch(C){throw Error(`v${W} migration failed for "${o}"`,{cause:C})}await n.setItems([{key:i,value:$},{key:p,value:{...R,v:c}}]),console.debug(`[@wxt-dev/storage] Storage migration completed for ${o} v${c}`,{migratedValue:$})},w=(s==null?void 0:s.migrations)==null?Promise.resolve():g().catch(p=>{console.error(`[@wxt-dev/storage] Migration failed for ${o}`,p)}),O=new ie,M=()=>(s==null?void 0:s.fallback)??(s==null?void 0:s.defaultValue)??null,b=()=>O.runExclusive(async()=>{const p=await n.getItem(i);if(p!=null||(s==null?void 0:s.init)==null)return p;const k=await s.init();return await n.setItem(i,k),k});return w.then(b),{key:o,get defaultValue(){return M()},get fallback(){return M()},getValue:async()=>(await w,s!=null&&s.init?await b():await f(n,i,s)),getMeta:async()=>(await w,await _(n,i)),setValue:async p=>(await w,await y(n,i,p)),setMeta:async p=>(await w,await m(n,i,p)),removeValue:async p=>(await w,await v(n,i,p)),removeMeta:async p=>(await w,await E(n,i,p)),watch:p=>x(n,i,(k,R)=>p(k??M(),R??M())),migrate:g}}}}function V(t){const e=()=>{if(P.runtime==null)throw Error(["'wxt/storage' must be loaded in a web extension environment",`
 - If thrown during a build, see https://github.com/wxt-dev/wxt/issues/371`,` - If thrown during tests, mock 'wxt/browser' correctly. See https://wxt.dev/guide/go-further/testing.html
`].join(`
`));if(P.storage==null)throw Error("You must add the 'storage' permission to your manifest to use 'wxt/storage'");const a=P.storage[t];if(a==null)throw Error(`"browser.storage.${t}" is undefined`);return a},r=new Set;return{getItem:async a=>(await e().get(a))[a],getItems:async a=>{const d=await e().get(a);return a.map(l=>({key:l,value:d[l]??null}))},setItem:async(a,d)=>{d==null?await e().remove(a):await e().set({[a]:d})},setItems:async a=>{const d=a.reduce((l,{key:h,value:f})=>(l[h]=f,l),{});await e().set(d)},removeItem:async a=>{await e().remove(a)},removeItems:async a=>{await e().remove(a)},snapshot:async()=>await e().get(),restoreSnapshot:async a=>{await e().set(a)},watch(a,d){const l=h=>{const f=h[a];f!=null&&(U(f.newValue,f.oldValue)||d(f.newValue??null,f.oldValue??null))};return e().onChanged.addListener(l),r.add(l),()=>{e().onChanged.removeListener(l),r.delete(l)}},unwatch(){r.forEach(a=>{e().onChanged.removeListener(a)}),r.clear()}}}const ce="*://*.localhost/*";new K(ce);const le=X(async()=>{I.runtime.onMessage.addListener(async function(t,e){var r,a,d,l,h,f;if(t.type==="apiReqRes"){const _=await T.getItem("local:website-id"),y=await T.getItem("local:userToken");if(_&&y){const m=((d=(a=(r=t==null?void 0:t.options)==null?void 0:r.data)==null?void 0:a.data)==null?void 0:d.url)||"";if(m.includes("favicon.ico")){console.log("Ignoring favicon request");return}if(console.log(t),t.options.data.type!="xhr-intercepted"||t.options.data.data.requestBody==null&&t.options.data.data.response==null)return;console.log("Processing user-initiated request:",m),console.log(N(m));let v=null,E=null,x=null;t.options.data.data.requestBody&&(v=J(t.options.data.data.requestBody)),t.options.data.data.response&&(E=J(t.options.data.data.response)),E&&(E[0].key,E[0].value,x=E[1].value),(v||x)&&await de(N(m),v,x,(f=(h=(l=t==null?void 0:t.options)==null?void 0:l.data)==null?void 0:h.data)==null?void 0:f.headers)&&I.tabs.query({active:!0,currentWindow:!0},function(A){var o,s,n,i,c,u;A.length>0&&A[0].id!==void 0?I.tabs.sendMessage(A[0].id,{action:"showDialog",url:m,method:t.options.data.data.method,request:v,response:x,headers:(n=(s=(o=t==null?void 0:t.options)==null?void 0:o.data)==null?void 0:s.data)==null?void 0:n.headers,params:(u=(c=(i=t==null?void 0:t.options)==null?void 0:i.data)==null?void 0:c.data)==null?void 0:u.params},function(g){I.runtime.lastError&&console.error("Error sending message:",I.runtime.lastError)}):console.error("No active tab found or tab ID is undefined.")})}}t.type=="endPointFormSubmitted"&&ue(t.data.method,t.data.request,t.data.response,t.data.url,t.data.headers,t.data.params)})});async function ue(t,e,r,a,d,l){try{I.tabs.query({active:!0,currentWindow:!0},function(E){E.length>0&&E[0].id!==void 0?I.tabs.sendMessage(E[0].id,{action:"showLoadingbar"},function(x){I.runtime.lastError&&console.error("Error sending message:",I.runtime.lastError)}):console.error("No active tab found or tab ID is undefined.")}),console.log("Adding endpoint:",{method:t,request:e,response:r,headers:d,url:a});const h=await T.getItem("local:website-id"),f=await T.getItem("local:userToken");if(!h||!f){console.error("Website ID or User Token is missing.");return}const _=N(a),y={websiteId:h,url:_,method:t,headers:d,requestBody:e||null,response:r||null,params:l||null},m=await fetch("https://api-documentation-extension.onrender.com/api/website/add-endpoint",{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${f}`},body:JSON.stringify(y)}),v=await m.json();m.ok?(console.log("Endpoint added successfully:",v),T.setItem("local:definedUrls",r.data.endpoints?r.data.endpoints:[])):console.error("Failed to add endpoint:",v.message||"Unknown error")}catch(h){console.error("Error adding endpoint to database:",h)}finally{I.tabs.query({active:!0,currentWindow:!0},function(h){h.length>0&&h[0].id!==void 0?I.tabs.sendMessage(h[0].id,{action:"hideLoadingbar"},function(f){I.runtime.lastError&&console.error("Error sending message:",I.runtime.lastError)}):console.error("No active tab found or tab ID is undefined.")})}}async function de(t,e,r,a){var d,l;if(t){let h=await T.getItem("local:definedUrls");if(Array.isArray(h)){for(const f of h)if(typeof f=="object"&&f!==null&&f.url===t){const _=f.requestBody===null&&e===null||JSON.stringify(f.requestBody)===JSON.stringify(e),y=f.response===null&&r===null||((d=f.response)==null?void 0:d.constructor)===Array&&(r==null?void 0:r.constructor)===Array&&fe(f.response,r)||((l=f.response)==null?void 0:l.constructor)===Object&&(r==null?void 0:r.constructor)===Object&&he(f.response,r),m=f.headers===null&&a===null||JSON.stringify(f.headers)===JSON.stringify(a);if(_&&y&&m)return!1}}return!0}return!1}function he(t,e){console.log("checking objects");const r=Object.keys(t).sort(),a=Object.keys(e).sort();if(r.length!==a.length)return!1;for(let d of r)if(t[d]!==e[d])return!1;return!0}function fe(t,e){if(t.length!==e.length)return!1;const r=l=>JSON.stringify(Object.keys(l).sort().reduce((h,f)=>(h[f]=l[f],h),{})),a=t.map(r).sort(),d=e.map(r).sort();return JSON.stringify(a)===JSON.stringify(d)}function N(t){try{const e=new URL(t);return e.pathname+e.search}catch(e){return console.error("Invalid URL:",e),null}}function J(t){try{const e=JSON.parse(t);return Object.entries(e).map(([a,d])=>({key:a,value:d,type:typeof d}))}catch(e){return console.error("Failed to parse JSON:",e),[]}}function we(){}function L(t,...e){}const me={debug:(...t)=>L(console.debug,...t),log:(...t)=>L(console.log,...t),warn:(...t)=>L(console.warn,...t),error:(...t)=>L(console.error,...t)};let F;try{F=le.main(),F instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(t){throw me.error("The background crashed on startup!"),t}return F}();
background;
